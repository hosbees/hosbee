// Swiper.js 간단 구현 (Swiper 라이브러리 대신 사용)
class SimpleSwiper {
    constructor(container, options = {}) {
        this.container = typeof container === 'string' ? document.querySelector(container) : container;
        this.options = {
            slidesPerView: options.slidesPerView || 1,
            spaceBetween: options.spaceBetween || 0,
            loop: options.loop || false,
            autoplay: options.autoplay || false,
            autoplayDelay: options.autoplayDelay || 3000,
            navigation: options.navigation || false,
            pagination: options.pagination || false,
            effect: options.effect || 'slide',
            speed: options.speed || 300,
            ...options
        };

        this.currentIndex = 0;
        this.slides = [];
        this.isAutoplayRunning = false;
        this.autoplayTimer = null;

        this.init();
    }

    init() {
        this.setupWrapper();
        this.setupSlides();
        this.setupNavigation();
        this.setupPagination();
        this.setupAutoplay();
        this.setupTouchEvents();
        this.updateSlidePosition();
    }

    setupWrapper() {
        this.container.classList.add('swiper-container');
        this.wrapper = this.container.querySelector('.swiper-wrapper');
        if (!this.wrapper) {
            this.wrapper = document.createElement('div');
            this.wrapper.className = 'swiper-wrapper';
            Array.from(this.container.children).forEach(child => {
                this.wrapper.appendChild(child);
            });
            this.container.appendChild(this.wrapper);
        }
    }

    setupSlides() {
        this.slides = Array.from(this.wrapper.children);
        this.slides.forEach((slide, index) => {
            slide.classList.add('swiper-slide');
            slide.style.width = `${100 / this.options.slidesPerView}%`;
            slide.style.flexShrink = '0';
            if (this.options.spaceBetween && index < this.slides.length - 1) {
                slide.style.marginRight = `${this.options.spaceBetween}px`;
            }
        });

        if (this.options.loop) {
            this.setupLoop();
        }

        this.wrapper.style.display = 'flex';
        this.wrapper.style.transition = `transform ${this.options.speed}ms ease`;
    }

    setupLoop() {
        const firstSlide = this.slides[0].cloneNode(true);
        const lastSlide = this.slides[this.slides.length - 1].cloneNode(true);

        this.wrapper.appendChild(firstSlide);
        this.wrapper.insertBefore(lastSlide, this.slides[0]);

        this.slides = Array.from(this.wrapper.children);
        this.currentIndex = 1;
    }

    setupNavigation() {
        if (this.options.navigation) {
            const navNext = this.container.querySelector('.swiper-button-next') ||
                           this.createButton('swiper-button-next', '›');
            const navPrev = this.container.querySelector('.swiper-button-prev') ||
                           this.createButton('swiper-button-prev', '‹');

            navNext.addEventListener('click', () => this.slideNext());
            navPrev.addEventListener('click', () => this.slidePrev());
        }
    }

    createButton(className, content) {
        const button = document.createElement('div');
        button.className = className;
        button.innerHTML = content;
        this.container.appendChild(button);
        return button;
    }

    setupPagination() {
        if (this.options.pagination) {
            let pagination = this.container.querySelector('.swiper-pagination');
            if (!pagination) {
                pagination = document.createElement('div');
                pagination.className = 'swiper-pagination';
                this.container.appendChild(pagination);
            }

            const slideCount = this.options.loop ? this.slides.length - 2 : this.slides.length;
            pagination.innerHTML = '';

            for (let i = 0; i < slideCount; i++) {
                const bullet = document.createElement('span');
                bullet.className = 'swiper-pagination-bullet';
                bullet.addEventListener('click', () => this.slideTo(i));
                pagination.appendChild(bullet);
            }

            this.updatePagination();
        }
    }

    setupAutoplay() {
        if (this.options.autoplay) {
            this.startAutoplay();

            this.container.addEventListener('mouseenter', () => this.stopAutoplay());
            this.container.addEventListener('mouseleave', () => this.startAutoplay());
        }
    }

    setupTouchEvents() {
        let startX = 0;
        let currentX = 0;
        let isDragging = false;

        this.wrapper.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = true;
            this.wrapper.style.transition = 'none';
        });

        this.wrapper.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            currentX = e.touches[0].clientX;
            const diff = currentX - startX;
            const translateX = -this.currentIndex * (100 / this.options.slidesPerView) + (diff / this.container.offsetWidth) * 100;
            this.wrapper.style.transform = `translateX(${translateX}%)`;
        });

        this.wrapper.addEventListener('touchend', () => {
            if (!isDragging) return;
            isDragging = false;
            this.wrapper.style.transition = `transform ${this.options.speed}ms ease`;

            const diff = currentX - startX;
            const threshold = this.container.offsetWidth * 0.1;

            if (Math.abs(diff) > threshold) {
                if (diff > 0) {
                    this.slidePrev();
                } else {
                    this.slideNext();
                }
            } else {
                this.updateSlidePosition();
            }
        });
    }

    slideNext() {
        if (this.options.loop) {
            this.currentIndex++;
            if (this.currentIndex >= this.slides.length - 1) {
                this.currentIndex = 1;
                this.wrapper.style.transition = 'none';
                this.wrapper.style.transform = `translateX(-${this.currentIndex * (100 / this.options.slidesPerView)}%)`;
                setTimeout(() => {
                    this.wrapper.style.transition = `transform ${this.options.speed}ms ease`;
                    this.currentIndex++;
                    this.updateSlidePosition();
                }, 10);
                return;
            }
        } else {
            this.currentIndex = Math.min(this.currentIndex + 1, this.slides.length - this.options.slidesPerView);
        }

        this.updateSlidePosition();
        this.updatePagination();
    }

    slidePrev() {
        if (this.options.loop) {
            this.currentIndex--;
            if (this.currentIndex <= 0) {
                this.currentIndex = this.slides.length - 2;
                this.wrapper.style.transition = 'none';
                this.wrapper.style.transform = `translateX(-${this.currentIndex * (100 / this.options.slidesPerView)}%)`;
                setTimeout(() => {
                    this.wrapper.style.transition = `transform ${this.options.speed}ms ease`;
                    this.currentIndex--;
                    this.updateSlidePosition();
                }, 10);
                return;
            }
        } else {
            this.currentIndex = Math.max(this.currentIndex - 1, 0);
        }

        this.updateSlidePosition();
        this.updatePagination();
    }

    slideTo(index) {
        if (this.options.loop) {
            this.currentIndex = index + 1;
        } else {
            this.currentIndex = index;
        }
        this.updateSlidePosition();
        this.updatePagination();
    }

    updateSlidePosition() {
        const translateX = -this.currentIndex * (100 / this.options.slidesPerView);

        if (this.options.effect === 'fade') {
            this.slides.forEach((slide, index) => {
                slide.style.opacity = index === this.currentIndex ? '1' : '0';
                slide.style.transition = `opacity ${this.options.speed}ms ease`;
            });
        } else {
            this.wrapper.style.transform = `translateX(${translateX}%)`;
        }
    }

    updatePagination() {
        if (!this.options.pagination) return;

        const bullets = this.container.querySelectorAll('.swiper-pagination-bullet');
        bullets.forEach((bullet, index) => {
            const activeIndex = this.options.loop ? this.currentIndex - 1 : this.currentIndex;
            bullet.classList.toggle('swiper-pagination-bullet-active', index === activeIndex);
        });
    }

    startAutoplay() {
        if (!this.options.autoplay || this.isAutoplayRunning) return;

        this.isAutoplayRunning = true;
        this.autoplayTimer = setInterval(() => {
            this.slideNext();
        }, this.options.autoplayDelay);
    }

    stopAutoplay() {
        if (!this.isAutoplayRunning) return;

        this.isAutoplayRunning = false;
        clearInterval(this.autoplayTimer);
    }

    destroy() {
        this.stopAutoplay();
        // 이벤트 리스너 제거 등 정리 작업
    }
}

// Global Swiper 함수
window.Swiper = SimpleSwiper;